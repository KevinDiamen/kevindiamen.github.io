---
layout: post
title: Web 安全 - XSS注入
category: Web安全
tags: [Web安全]
---

# Web 安全 - XSS

- [介绍](#introduction)
- [XSS注入防御](#person-ssl)

<a name="introduction"></a>
## 介绍
跨站脚本攻击(Cross Site Scripting)。 恶意攻击者往Web页面里插入恶意Script代码，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的

## XSS注入防御
 
### 输出也需要进行过滤
What security benefits come from escaping user-generated data that you output? Suppose a user submits the following JavaScript snippet to your application, which saves it for outputting later:<script>alert('I am not sanitized!');</script>If you don’t sanitize this code before you echo it out to the browser, the malicious JavaScript will run normally, as if you wrote it yourself. In this case it’s a harmless alert(), but a hacker won’t be nearly as kind.Another popular place for this type of exploit is in an image’s XIFF data. If a user uploads an image and your application displays the XIFF data, it will need to be sanitized as well. Anywhere you are displaying data that came into your app from the outside, you need to sanitize it.If you’re using a templating library or a framework that handles templating, escaping may happen automatically, or
Chapter 1 - Never Trust Your Users. Sanitize ALL Input! 16there is a built-in method for doing so. Make sure to check the documentation for your library / framework of choice to determine how this works.For those of you handling this yourself, PHP provides a coupleof functions that will be your best friends when displaying data in the browser: htmlentities()9 and htmlspecialchars()10. Both will escape and manipulate data to make it safer before rendering.htmlspecialchars() should be your go-to function in 90% of cases. It will look for characters with special meaning (e.g., <, >, &) and encode these characters to HTML entities.htmlentities() is like htmlspecialchars() on steroids. It will encode any character into its HTML entity equivalent if one exists. This may or may not be what you need in many cases. Make sure to understand what each one of these functions does exactly, then evaluate which is best for the type of data you are sending to the browser.
