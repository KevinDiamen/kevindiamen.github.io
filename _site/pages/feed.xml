<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>闫肃的个人博客</title>
    <description>闫肃的博客
</description>
    <link>http://yansu.org/</link>
    <atom:link href="http://yansu.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 22 Apr 2016 17:10:37 +0800</pubDate>
    <lastBuildDate>Fri, 22 Apr 2016 17:10:37 +0800</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>Vim 常用资源</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;在粘贴代码时不启动自动缩进&lt;/h2&gt;

&lt;p&gt;粘贴之前输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;:set paste&lt;/code&gt;
粘贴完后恢复 &lt;code class=&quot;highlighter-rouge&quot;&gt;:set nopaste&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;关闭和开启行号&lt;/h2&gt;

&lt;p&gt;关闭 &lt;code class=&quot;highlighter-rouge&quot;&gt;:set nonu&lt;/code&gt;
开启 &lt;code class=&quot;highlighter-rouge&quot;&gt;:set number&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 04 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2015/10/04/general-vim-resources.html</link>
        <guid isPermaLink="true">http://yansu.org/2015/10/04/general-vim-resources.html</guid>
        
        <category>Vim</category>
        
        
        <category>资源</category>
        
      </item>
    
      <item>
        <title>七种常见经典排序算法总结（C++实现）</title>
        <description>&lt;p&gt;排序算法是非常常见也非常基础的算法，以至于大部分情况下它们都被集成到了语言的辅助库中。排序算法虽然已经可以很方便的使用，但是理解排序算法可以帮助我们找到解题的方向。&lt;/p&gt;

&lt;h2 id=&quot;bubble-sort&quot;&gt;1. 冒泡排序 (Bubble Sort)&lt;/h2&gt;

&lt;p&gt;冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从左开始比较相邻的两个元素x和y，如果 x &amp;gt; y 就交换两者&lt;/li&gt;
  &lt;li&gt;执行比较和交换，直到到达数组的最后一个元素&lt;/li&gt;
  &lt;li&gt;重复执行1和2，直到执行n次，也就是n个最大元素都排到了最后&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;void bubble_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums)
{
    for (int i = 0; i &amp;lt; nums.size() - 1; i++) { // times
        for (int j = 0; j &amp;lt; nums.size() - i - 1; j++) { // position
            if (nums[j] &amp;gt; nums[j + 1]) {
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;交换的那一步可以不借助temp，方法是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;nums[j] += nums[j + 1];
nums[j + 1] = num[j] - nums[j + 1];
nums[j] -= num[j + 1];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;(a1 + an) * n / 2&lt;/code&gt;），也就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^2)&lt;/code&gt;。 空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;insertion-sort&quot;&gt;2. 插入排序（Insertion Sort）&lt;/h2&gt;

&lt;p&gt;插入排序的原理是从左到右，把选出的一个数和前面的数进行比较，找到最适合它的位置放入，使前面部分有序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从左开始，选出当前位置的数x，和它之前的数y比较，如果x &amp;lt; y则交换两者&lt;/li&gt;
  &lt;li&gt;对x之前的数都执行1步骤，直到前面的数字都有序&lt;/li&gt;
  &lt;li&gt;选择有序部分后一个数字，插入到前面有序部分，直到没有数字可选择&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;void insert_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums)
{
    for (int i = 1; i &amp;lt; nums.size(); i++) { // position
        for (int j = i; j &amp;gt; 0; j--) {
            if (nums[j] &amp;lt; nums[j - 1]) {
                int temp = nums[j];
                nums[j] = nums[j - 1];
                nums[j - 1] = temp;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^2)&lt;/code&gt;。空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;selection-sort&quot;&gt;3. 选择排序（Selection Sort）&lt;/h2&gt;

&lt;p&gt;选择排序的原理是，每次都从乱序数组中找到最大（最小）值，放到当前乱序数组头部，最终使数组有序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从左开始，选择后面元素中最小值，和最左元素交换&lt;/li&gt;
  &lt;li&gt;从当前已交换位置往后执行，直到最后一个元素&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;void selection_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums)
{
    for (int i = 0; i &amp;lt; nums.size(); i++) { // position
        int min = i;
        for (int j = i + 1; j &amp;lt; nums.size(); j++) {
            if (nums[j] &amp;lt; nums[min]) {
                min = j;
            }
        }

        int temp = nums[i];
        nums[i] = nums[min];
        nums[min] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^2)&lt;/code&gt;。空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;shell-sort&quot;&gt;4. 希尔排序（Shell Sort）&lt;/h2&gt;

&lt;p&gt;希尔排序从名字上看不出来特点，因为它是以发明者命名的。它的另一个名字是“递减增量排序算法“。这个算法可以看作是插入排序的优化版，因为插入排序需要一位一位比较，然后放置到正确位置。为了提升比较的跨度，希尔排序将数组按照一定步长分成几个子数组进行排序，通过逐渐减短步长来完成最终排序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;[10, 80, 70, 100, 90, 30, 20]&lt;/code&gt;
如果我们按照一次减一半的步长来算， 这个数组第一次排序时以3为步长，子数组是：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;10 80 70&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;90 30 20&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;100&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里其实按照列划分的4个子数组，排序后结果为&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;10 30 20&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;90 80 70&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;100&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;也就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;[10, 30 20 90 80 70 100]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后再以1为步长生成子数组&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;30&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;..&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个时候就是一纵列了，也就是说最后一定是以一个数组来排序的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算当前步长，按步长划分子数组&lt;/li&gt;
  &lt;li&gt;子数组内插入排序&lt;/li&gt;
  &lt;li&gt;步长除以2后继续12两步，直到步长最后变成1&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;void shell_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums)
{
    for (int gap = nums.size() &amp;gt;&amp;gt; 1; gap &amp;gt; 0; gap &amp;gt;&amp;gt;= 1) { // times
        for (int i = gap; i &amp;lt; nums.size(); i++) { // position
            int temp = nums[i];

            int j = i - gap;
            for (; j &amp;gt;= 0 &amp;amp;&amp;amp; nums[j] &amp;gt; temp; j -= gap) {
                nums[j + gap] = nums[j];
            }

            nums[j + gap] = temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;希尔排序的时间复杂度受步长的影响，具体分析在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97&quot;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;merge-sort&quot;&gt;5. 归并排序（Merge Sort）&lt;/h2&gt;

&lt;p&gt;归并排序是采用分治法（Divide and Conquer）的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;把当前数组分化成n个单位为1的子数组，然后两两比较合并成单位为2的n/2个子数组&lt;/li&gt;
  &lt;li&gt;继续进行这个过程，按照2的倍数进行子数组的比较合并，直到最终数组有序&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;void merge_array(vector&amp;lt;int&amp;gt; &amp;amp;nums, int b, int m, int e, vector&amp;lt;int&amp;gt; &amp;amp;temp)
{
    int lb = b, rb = m, tb = b;
    while (lb != m &amp;amp;&amp;amp; rb != e)
        if (nums[lb] &amp;lt; nums[rb])
            temp[tb++] = nums[lb++];
        else
            temp[tb++] = nums[rb++];

    while (lb &amp;lt; m)
        temp[tb++] = nums[lb++];
    
    while (rb &amp;lt; e)
        temp[tb++] = nums[rb++];

    for (int i = b;i &amp;lt; e; i++)
        nums[i] = temp[i];
}

void merge_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums, int b, int e, vector&amp;lt;int&amp;gt; &amp;amp;temp)
{
    int m = (b + e) / 2;
    if (m != b) {
        merge_sort(nums, b, m, temp);
        merge_sort(nums, m, e, temp);
        merge_array(nums, b, m, e, temp);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现中加了一个temp，是和原数组一样大的一个空间，用来临时存放排序后的子数组的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;merge_array&lt;/code&gt;过程中，实际的操作是当前两个子数组的长度，即2m。又因为打散数组是二分的，最终循环执行数是&lt;code class=&quot;highlighter-rouge&quot;&gt;logn&lt;/code&gt;。所以这个算法最终时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(nlogn)&lt;/code&gt;，空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;quick-sort&quot;&gt;6. 快速排序（Quick Sort）&lt;/h2&gt;

&lt;p&gt;快速排序也是利用分治法实现的一个排序算法。快速排序和归并排序不同，它不是一半一半的分子数组，而是选择一个基准数，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同步骤，直到整个数组有序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用一个基准数将数组分成两个子数组&lt;/li&gt;
  &lt;li&gt;将大于基准数的移到右边，小于的移到左边&lt;/li&gt;
  &lt;li&gt;递归的对子数组重复执行1，2，直到整个数组有序&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;void quick_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums, int b, int e, vector&amp;lt;int&amp;gt; &amp;amp;temp)
{
    int m = (b + e) / 2;
    if (m != b) {
        int lb = b, rb = e - 1;

        for (int i = b; i &amp;lt; e; i++) {
            if (i == m)
                continue;
            if (nums[i] &amp;lt; nums[m])
                temp[lb++] = nums[i];
            else
                temp[rb--] = nums[i];
        }
        temp[lb] = nums[m];
        
        for (int i = b; i &amp;lt; e; i++)
            nums[i] = temp[i];
        
        quick_sort(nums, b, lb, temp);
        quick_sort(nums, lb + 1, e, temp);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解法2: 不需要辅助空间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;void quick_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums, int b, int e)
{
    if (b &amp;lt; e - 1) {
        int lb = b, rb = e - 1;
        while (lb &amp;lt; rb) {
            while (nums[rb] &amp;gt;= nums[b] &amp;amp;&amp;amp; lb &amp;lt; rb)
                rb--;
            while (nums[lb] &amp;lt;= nums[b] &amp;amp;&amp;amp; lb &amp;lt; rb)
                lb++;
            swap(nums[lb], nums[rb]);
        }
        swap(nums[b], nums[lb]);
        quick_sort(nums, b, lb);
        quick_sort(nums, lb + 1, e);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;快速排序也是一个不稳定排序，时间复杂度看&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#.E5.B9.B3.E5.9D.87.E8.A4.87.E9.9B.9C.E5.BA.A6&quot;&gt;维基百科&lt;/a&gt;。空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;heap-sort&quot;&gt;7. 堆排序（Heap Sort）&lt;/h2&gt;

&lt;p&gt;堆排序经常用于求一个数组中最大k个元素时。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为当前堆中最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前k大元素，或者使堆有序。&lt;/p&gt;

&lt;p&gt;在了解算法之前，首先了解在一维数组中节点的下标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;i节点的父节点 parent(i) = floor((i-1)/2)&lt;/li&gt;
  &lt;li&gt;i节点的左子节点 left(i) = 2i + 1&lt;/li&gt;
  &lt;li&gt;i节点的右子节点 right(i) = 2i + 2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;构造最大堆（Build Max Heap）：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到比较到根节点。重复执行到最后一个元素。&lt;/li&gt;
  &lt;li&gt;最大堆调整（Max Heapify）：调整最大堆即将根节点移除后重新整理堆。整理方法为将根节点和最后一个节点交换，然后把堆看做n-1长度，将当前根节点逐步移动到其应该在的位置。&lt;/li&gt;
  &lt;li&gt;堆排序（HeapSort）：重复执行2，直到所有根节点都已移除。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-CPP&quot;&gt;void heap_sort(vector&amp;lt;int&amp;gt; &amp;amp;nums)
{
    int n = nums.size();
    for (int i = n / 2 - 1; i &amp;gt;= 0; i--) { // build max heap
        max_heapify(nums, i, nums.size() - 1);
    }
    
    for (int i = n - 1; i &amp;gt; 0; i--) { // heap sort
        int temp = nums[i];
        num[i] = nums[0];
        num[0] = temp;
        max_heapify(nums, 0, i);
    }
}

void max_heapify(vector&amp;lt;int&amp;gt; &amp;amp;nums, int beg, int end)
{
    int curr = beg;
    int child = curr * 2 + 1;
    while (child &amp;lt; end) {
        if (child + 1 &amp;lt; end &amp;amp;&amp;amp; nums[child] &amp;lt; nums[child + 1]) {
            child++;
        }
        if (nums[curr] &amp;lt; nums[child]) {
            int temp = nums[curr];
            nums[curr] = nums[child];
            num[child] = temp;
            curr = child;
            child = 2 * curr + 1;
        } else {
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;堆执行一次调整需要&lt;code class=&quot;highlighter-rouge&quot;&gt;O(logn)&lt;/code&gt;的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(nlogn)&lt;/code&gt;。空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;0. 参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;维基百科&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/&quot;&gt;经典排序算法总结与实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000002466215&quot;&gt;堆排序C++实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/&quot;&gt;常见排序算法 - 堆排序 (Heap Sort)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 07 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2015/09/07/sort-algorithms.html</link>
        <guid isPermaLink="true">http://yansu.org/2015/09/07/sort-algorithms.html</guid>
        
        <category>算法</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>使用 Zipcar 在加州租车</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在洛杉矶这个“大饼”中生活，没有车真的是各种艰难。2月初把驾照考过了，接下来就考虑买车或者租车。买车算了算不是很划算，而且对车也不太懂，就考虑先租车。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 &lt;a href=&quot;http://transnet.usc.edu/index.php/getting-around/&quot;&gt;USC Transportation&lt;/a&gt; 上排名最靠前的两个公司是 Enterprise 和 Zipcar。前者是传统的租车公司，后者稍微不一样一点。我还没有在 Enterprise 上租过车，所以先说说 Zipcar.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;zipcar-&quot;&gt;Zipcar 简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zipcar.com&quot;&gt;Zipcar&lt;/a&gt; 是会员制的，在注册以后会给发一张 Zipcard 过来，有了这张卡你就可以随时去订车和提车了。Zipcar 不像其他租车行一样你得去固定地方统一取车，它的车就停在路边，他们有固定的停车位。来看一下 Zipcar 在 USC 附近的停车点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-zipcar-map.png&quot; alt=&quot;zipcar map&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;zipcar--1&quot;&gt;Zipcar 使用&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 注册获得会员卡&lt;/h3&gt;

&lt;p&gt;大部分学校应该都和 Zipcar 有合作，所以注册之前应该去学校网站看一下。学生可以将会员费缩减到 25刀/年。&lt;/p&gt;

&lt;p&gt;注册地址在&lt;a href=&quot;http://members.zipcar.com/registration&quot;&gt;这里&lt;/a&gt;，注册的时候去搜一下 Promo Code，我就是注册完才看到一个免费40刀的 Code T_T。在美国注册帐号一看到 Code 填空就应该去搜搜~&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 租车&lt;/h3&gt;

&lt;p&gt;租车可以在网站上或者手机 APP 上进行。租车非常方便，只要选择相应车辆，以及使用时间预订即可。然后在预订时间的前15分钟内取车。取车很简单，拿自己的 Zipcard 刷一下车前部的一个感应器门就开了。然后上车发动走人。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3. 加油&lt;/h3&gt;

&lt;p&gt;Zipcar 租的车带了加油卡，就在司机座位上面。虽然看起来比较贴心，但是这个卡经常不能用，因为它似乎是个信用卡，然后一旦有人尝试多次失败就被锁了，导致后面的人们也不能用。&lt;/p&gt;

&lt;p&gt;加油卡的使用方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;刷一下加油卡 (Gas Card)&lt;/li&gt;
  &lt;li&gt;输入汽车里程表上的数&lt;/li&gt;
  &lt;li&gt;输入 Zipcard 上面那个 6 位的 Gas ID&lt;/li&gt;
  &lt;li&gt;加油&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果加油卡失效，这个时候会提示：Find your cashier。不用担心，直接用自己的信用卡加油就好了，然后记得要收据 (Receipt)，然后把收据发到 support@zipcar.com 报销就好。记得在邮件里加上自己的 Zipcard ID.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4. 还车&lt;/h3&gt;

&lt;p&gt;还车记得一定要还到原车的位置。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;5. 保险&lt;/h3&gt;

&lt;p&gt;在帐号注册的时候有个保险选项&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-zipcar-damage-fee.png&quot; alt=&quot;damage fee&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我建议选择那个complete waiver，毕竟开车难免磕碰。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;注意&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;1. 逾期罚款&lt;/h3&gt;

&lt;p&gt;租车的时候宁可多不可少，因为逾期惩罚是非常重的，应该是一个小时50刀左右。&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2015/04/13/rent-car-by-zipcar.html</link>
        <guid isPermaLink="true">http://yansu.org/2015/04/13/rent-car-by-zipcar.html</guid>
        
        <category>Essay</category>
        
        
        <category>生活</category>
        
      </item>
    
      <item>
        <title>SEO 常用资源</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;小技巧&lt;/h2&gt;

&lt;h3 id=&quot;url-&quot;&gt;URL中用&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;分割单词，用&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;关联单词&lt;/h3&gt;

&lt;p&gt;Google 会把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a-good_reource-of-seo.html&lt;/code&gt; 拆分成关键字：&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;good_resource&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;of&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;seo&lt;/code&gt;。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Feb 2015 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2015/02/13/general-seo-resources.html</link>
        <guid isPermaLink="true">http://yansu.org/2015/02/13/general-seo-resources.html</guid>
        
        <category>SEO</category>
        
        
        <category>资源</category>
        
      </item>
    
      <item>
        <title>微软 Openhack 2015</title>
        <description>&lt;p&gt;Hackathon 在国内也见过不少，不过一直没有参加过，一是熬夜实在是伤身体，二是以前不太好找队伍。这回室友喊我去参加，因为好奇这边IT的工作环境，就去参加了。&lt;/p&gt;

&lt;p&gt;这次 Hackathon 的主题是 USC vs UCLA，这俩学校的 Football 一直是死敌，导致各方面也都开始竞争，在 &lt;a href=&quot;http://en.wikipedia.org/wiki/UCLA–USC_rivalry&quot;&gt;Wikipedia&lt;/a&gt; 上还有专门的词条来记录两校的竞争。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-openhack-usc-vs-ucla.png&quot; alt=&quot;USC vs UCLA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是 Hackathon 一组队伍最终展示PPT时候的封面~&lt;/p&gt;

&lt;p&gt;这次 Openhack 的奖品还好，第一是去西雅图总部玩，第二是人手一台XBOX.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-openhack-prize.png&quot; alt=&quot;Prize&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不过在中间每隔一个小时有一次小活动，奖品包含了XBOX和Surface Pro等 0_0 可惜活动都没法参加，对游戏规则都不明白。不过这边的工程师们还是挺逗的，唱歌跳舞神马的各种玩 High。&lt;/p&gt;

&lt;p&gt;下图是洛杉矶微软办公室，这天里面基本上能坐的地方都被参加 Hackathon 的队伍挤满了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-openhack-microsoft-office.png&quot; alt=&quot;Office&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们的4个人的桌面~ 隔壁一哥带外星人来写代码，不过据说装了10个小时，Visual Studio 都没装完。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-openhack-table.png&quot; alt=&quot;table&quot; /&gt;
 最后是队伍合影 =_= 我是那个比较正常的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-openhack-team.png&quot; alt=&quot;team&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2015/01/30/microsoft-openhack-2015.html</link>
        <guid isPermaLink="true">http://yansu.org/2015/01/30/microsoft-openhack-2015.html</guid>
        
        <category>Essay</category>
        
        
        <category>生活</category>
        
      </item>
    
      <item>
        <title>使用Dropzone和七牛云存储来优化博客图床</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;2015.12.20更新
- 此次更新用Python替代了Ruby，不需要再自己安装qiniu的ruby包，我已经集成在bundle里面
- 增加了一个pngpaste在包里，这样直接点击action会把剪切板内的图片上传 (已测试系统截图，QQ截图以及Monosnap)，原来的点击打开七牛官网功能在剪切版没有图片时生效
- 增加了图片重名检查&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前我在用SAE的Storage作为博客图床，但是令我非常不爽的是没有一个很好的上传和获得公共链接的方法。现在总算用Dropzone和七牛把这个问题解决了，下面是我上传图片和获得URL的操作，方法再往下看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-workflow.gif&quot; alt=&quot;七牛操作流&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;设置七牛帐号&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.qiniu.com&quot;&gt;七牛&lt;/a&gt;是国内口碑不错的一个云存储为主的公司。它的特点应该就在图片存储上，有非常方便的上传SDK和图片处理流，用来作为博客图床非常合适，而且价格不贵，每月有免费的10G流量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;去七牛注册帐号&lt;/p&gt;

    &lt;p&gt;刚刚创建的帐号是测试帐号，完成个人认证就可以成为标准帐号，获得10G的存储空间和各10G的上传下载流量。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-normal-account.png&quot; alt=&quot;标准帐号&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个空间&lt;/p&gt;

    &lt;p&gt;创建空间也比较容易，记得选择公开空间。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-create-bucket.png&quot; alt=&quot;创建空间&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;dropzone&quot;&gt;设置Dropzone&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://aptonic.com/dropzone3/&quot;&gt;Dropzone&lt;/a&gt;是我很早就非常喜欢的一个软件。它通过拖拽的方式，增强了文件的处理流程。一直懒得给它开发插件，没想到七牛的SDK如此好用，所以今天折腾了一下搞定了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载软件&lt;/p&gt;

    &lt;p&gt;这个软件可以在App Store上直接购买，但是买到的是功能受限的，它不能操作外部文件。不过没有关系，再从官网上下载非沙箱版本，然后覆盖掉Application文件夹下的即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装Qiniu插件&lt;/p&gt;

    &lt;p&gt;我把这个插件放到了&lt;a href=&quot;https://github.com/suyan/scripts/tree/master/Dropzone%20Action&quot;&gt;Github&lt;/a&gt;上，戳&lt;a href=&quot;https://github.com/suyan/scripts/blob/master/Dropzone%20Action/Qiniu.dzbundle.zip?raw=true&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装插件&lt;/p&gt;

    &lt;p&gt;下载后的是一个zip包，把这个包解压以后双击安装即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用插件&lt;/p&gt;

    &lt;p&gt;从增加列表中选择我们安装好的七牛插件。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-use-bundle.png&quot; alt=&quot;启用插件&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;然后填写配置：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;server: 七牛上的空间名&lt;/li&gt;
      &lt;li&gt;username: 七牛的access_key&lt;/li&gt;
      &lt;li&gt;password: 七牛的secret_key&lt;/li&gt;
      &lt;li&gt;remote path(可选): 本地同步图片的目录，如果你希望本地也存一份图片，选一个地址即可&lt;/li&gt;
      &lt;li&gt;root url: 七牛的公共链接根目录&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-access-key.png&quot; alt=&quot;access key&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/tool-qiniu-root-url.png&quot; alt=&quot;root url&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;其他建议&lt;/h2&gt;

&lt;p&gt;利用Dropzone还有很多可利用的技巧，例如增加一个ImageOptim应用来压缩图片，然后再进行上传。&lt;/p&gt;

&lt;p&gt;对于临时图片，可以直接上传到Imgur获得链接。&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2015/01/10/use-dropzone-and-qiniu-to-store-blog-images.html</link>
        <guid isPermaLink="true">http://yansu.org/2015/01/10/use-dropzone-and-qiniu-to-store-blog-images.html</guid>
        
        <category>Blog</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>Laravel 关联模型由于名称一致性导致的问题</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;1. 定义关联模型&lt;/h2&gt;

&lt;p&gt;在Laravel里面，我们可以通过定义以下Model来完成关联查询。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyPost extends Eloquent {
    public function myPostInfo () {
        return $this-&amp;gt;hasOne(&#39;MyPostInfo&#39;);
    }
}

class MyPostInfo extends Eloquent {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2. 使用关联模型&lt;/h2&gt;

&lt;p&gt;这里&lt;code class=&quot;highlighter-rouge&quot;&gt;myPostInfo()&lt;/code&gt;用的是Camel命名规则，但是我们在读取某一个PostInfo的时候可以用Snake规则。如下面代码都是可行的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$post = MyPost::find(1);
$post_info = $post-&amp;gt;myPostInfo; // example 1
$post_info = $post-&amp;gt;my_post_info; // example 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Laravel允许上述两种方法，但是没有合理的处理使用两种命名造成的冲突。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3. 缓存失效&lt;/h2&gt;

&lt;p&gt;如果我们同时使用了上述两个例子，就会使其中一个缓存失效。在Model的relations变量中，缓存了已经读取过的关联Model，但是当我们用不同规则的名字去读取的时候，却会使得前一个缓存失效。例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$post_info = $post-&amp;gt;myPostInfo; 
// $post-&amp;gt;relations = [‘myPostInfo’ =&amp;gt; ..];

$post_info = $post-&amp;gt;my_post_info;
// $post-&amp;gt;relations = [‘myPostInfo’ =&amp;gt; …, ‘my_post_info’ =&amp;gt; …];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以如果不希望缓存失效，得在项目中只使用一种命名方法去读取关系模型。Laravel推荐的是Camel Case.&lt;/p&gt;

&lt;h2 id=&quot;toarray-&quot;&gt;4. toArray() 方法失效&lt;/h2&gt;

&lt;p&gt;如果同时使用了两者，另外一个问题就是导致&lt;code class=&quot;highlighter-rouge&quot;&gt;Model::toArray()&lt;/code&gt;失效。因为&lt;code class=&quot;highlighter-rouge&quot;&gt;toArray()&lt;/code&gt;方法首先去&lt;code class=&quot;highlighter-rouge&quot;&gt;relations&lt;/code&gt;中查找Snake Case命名的关联模型，没有的话才去看Camel Case的。&lt;/p&gt;

&lt;p&gt;所以如果用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;toArray()&lt;/code&gt;方法来转换Model，切忌同时使用两者。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;5. 容易犯错的位置&lt;/h2&gt;

&lt;p&gt;最容易犯错的代码是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MyPost::with(‘myPostInfo’)-&amp;gt;get();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在使用With去eagerLoad关联模型时，必须使用和定义方法同名的key去读取，那么这样读取出来的方法只能是Camel Case的key。其他地方就只能用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$my_post-&amp;gt;myPostInfo;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来保证不出问题。&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2015/01/08/conflict-between-camel-and-snake-in-laravel.html</link>
        <guid isPermaLink="true">http://yansu.org/2015/01/08/conflict-between-camel-and-snake-in-laravel.html</guid>
        
        <category>PHP</category>
        
        <category>Laravel</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>2014 个人总结</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在2014年里，我在求学、职业生涯以及家庭关系上都有过多次尝试和选择。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;留学申请&lt;/h2&gt;

&lt;p&gt;英语考试和学校申请总的时间大概是从去年8月中旬到今年1月中旬，历时5个月，这段时间是我有记忆以来最困难的一段时期。其中包括说服家人支持我留学，考过TOEFL和GRE，以及学校的选择和申请。&lt;/p&gt;

&lt;p&gt;最后由于考试结果不理想，只申请了一个学校尝试，之后打算继续考试和准备来年的申请。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;远程工作&lt;/h2&gt;

&lt;p&gt;从13年底加入澳洲这家公司，到今年5月离开，是我第一次尝试远程工作。由于那边公司节奏也不快，所以除了工作外，我可以有闲暇的时间完成留学的各种琐事，以及处理研究生学校退学的一些事情。&lt;/p&gt;

&lt;p&gt;工作中收获很多，一方面要熟悉远程工作方式，另一方面为了实现项目的需求需要不断学习提升自己。最后积累了比较多的网络安全知识和实际开发经验。&lt;/p&gt;

&lt;p&gt;但是后来由于公司重组，原定的很多计划都不能再继续，因此我有了很长一段空闲期。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;几次旅行&lt;/h2&gt;

&lt;p&gt;这段空闲期里，正好给了我很多机会出去旅行。我在14年上半年去游了华山和普陀山。一直想抽空把图片整理一下，写一下游记… 但是一直没有完成，看来只能拖到15年了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;新公司&lt;/h2&gt;

&lt;p&gt;旅行归来以后开始考虑自己接下来的计划，选择一个既有利于自己发展，又对个人限制比较少的公司工作，这样可以让我继续自己留学的目标。&lt;/p&gt;

&lt;p&gt;在几次面试和选择以后，最后加入了一个创业公司，开始全职工作。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;留学&lt;/h2&gt;

&lt;p&gt;5月中旬，我不幸被一波拒信AOE砸中。14Fall的入学没戏了，不过学校接着给我发来一封调剂录取，说我如果愿意接受学校国际学校的语言课程，可以14Fall加入国际学院，然后15Spring或者15Fall再进入正式的Master学院。&lt;/p&gt;

&lt;p&gt;和家人和老板都商量过以后，确定接受调剂，先到美帝熟悉环境。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;语言学习&lt;/h2&gt;

&lt;p&gt;语言学习过程其实也是熟悉未来生活和学习环境的过程。事实证明早来也有早来的好处，经过几个月的学习，我的英文水平可以应付了日常生活和学术的基本要求。&lt;/p&gt;

&lt;p&gt;其间除了探索洛杉矶，还去过一次旧金山旅行，感受了一下湾区风光。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;总得说来，这一年经历了很多，也成长了很多。&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Jan 2015 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2015/01/01/my-2014.html</link>
        <guid isPermaLink="true">http://yansu.org/2015/01/01/my-2014.html</guid>
        
        <category>Essay</category>
        
        
        <category>生活</category>
        
      </item>
    
      <item>
        <title>美西加州三日游</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;来美3个月了，终于迎来第一个小假期。由于时间有限，还没有车，所以选择了跟团先粗略了解一下加州。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-travel-of-california.png&quot; alt=&quot;map of travel&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;solvang&quot;&gt;丹麦村 (Solvang)&lt;/h2&gt;

&lt;p&gt;丹麦村是我们的第一站停歇点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-solvang-street.jpg&quot; alt=&quot;solvang street&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里的建筑风格都特别小清醒，多重色彩穿插点缀整条大街。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-solvang-windmill.jpg&quot; alt=&quot;solvang windmill&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个风车是这儿的标志建筑，配合加州的大蓝天，可以拍很多不错的照片。&lt;/p&gt;

&lt;h2 id=&quot;hearst-castle&quot;&gt;赫氏古堡 (Hearst Castle)&lt;/h2&gt;

&lt;p&gt;第二站是赫氏古堡，在地图上的C点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-hearst-castle-appearance.jpg&quot; alt=&quot;hearst castle appearance&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这座城堡建在一座山头，城堡中收藏了各种珍贵的雕像和油画。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-hearst-castle-outside.jpg&quot; alt=&quot;hearst castle outside&quot; /&gt;&lt;/p&gt;

&lt;p&gt;向西眺望就是沙滩和太平洋，视野非常开阔。&lt;/p&gt;

&lt;h2 id=&quot;palace-of-fine-arts&quot;&gt;罗马艺术宫 (Palace of Fine Arts)&lt;/h2&gt;

&lt;p&gt;罗马艺术宫就坐落在进门大桥旁边，据说是当初万国博览会举办的地方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-palace-of-fine-arts.jpg&quot; alt=&quot;palace of fine arts&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;lombard-street&quot;&gt;九曲花街 (Lombard Street)&lt;/h2&gt;

&lt;p&gt;很多人推荐九曲花街这个地方，但是我们来的时候两边花并没有开，所以看起来就是一个大家练车的地方 0_0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-lombard-street.jpg&quot; alt=&quot;lombard street&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;fishermans-wharf&quot;&gt;渔人码头 (Fisherman’s Wharf)&lt;/h2&gt;

&lt;p&gt;渔人码头这个地方就像一个游客集散地，来的都是外地游客。这里有各种海鲜可以尝，另外广场的歌手唱的也挺不错。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-fishermans-wharf-gate-1.jpg&quot; alt=&quot;fisherman&#39;s wharf&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;alcatraz-island&quot;&gt;恶魔岛 (Alcatraz Island)&lt;/h2&gt;

&lt;p&gt;从渔人码头上船，可以绕恶魔岛一圈。恶魔岛以前是关政治罪犯的地方，孤立在海中央，非常难越狱，不过据说有人挖了地道到了对岸。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-alcatraz-island.jpg&quot; alt=&quot;alcatraz island&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;golden-gate-bridge&quot;&gt;金门大桥 (Golden Gate Bridge)&lt;/h2&gt;

&lt;p&gt;金门大桥算是旧金山的标志之一。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-golden-gate-bridge.jpg&quot; alt=&quot;golden gate bridge&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;yosemite&quot;&gt;优胜美地国家公园 (Yosemite)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-yosemite-artists-point.jpg&quot; alt=&quot;Yosemite Artist&#39;s Point&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-yosemite-trees.jpg&quot; alt=&quot;Yosemite Trees&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-yosemite-fall.jpg&quot; alt=&quot;Yosemite Fall&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/life-yosemite-ei-captain.jpg&quot; alt=&quot;Yosemite EI Captain&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2014/12/12/travel-of-california.html</link>
        <guid isPermaLink="true">http://yansu.org/2014/12/12/travel-of-california.html</guid>
        
        <category>essay</category>
        
        
        <category>生活</category>
        
      </item>
    
      <item>
        <title>Laravel 核心：控制反转（Inversion of Control）和门面模式（Facade）</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这两个概念对于 Laravel 的使用者来说应该并不陌生，尤其是当你希望扩展或者替换 Laravel 核心库的时候，理解和合理使用它们可以极大提升 Laravel 的战斗力。这里以创建一个自己的 ServiceProvider 为例理解 Inversion of Control 和 Facade 在 Laravel 中的应用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;inversion-of-control&quot;&gt;控制反转（Inversion of Control）&lt;/h2&gt;

&lt;h3 id=&quot;ioc&quot;&gt;什么是 IoC&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。 — &lt;a href=&quot;http://zh.wikipedia.org/wiki/控制反转&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单说来，就是一个类把自己的的控制权交给另外一个对象，类间的依赖由这个对象去解决。依赖注入属于依赖的显示申明，而依赖查找则是通过查找来解决依赖。&lt;/p&gt;

&lt;h3 id=&quot;laravel-&quot;&gt;Laravel 中的使用&lt;/h3&gt;

&lt;p&gt;注入一个类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;App::bind(&#39;foo&#39;, function($app)
{
    return new FooBar;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个例子的意思是创建一个别名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; 的类，使用时实际实例化的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;FooBar&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;使用这个类的方法是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$value = App::make(&#39;foo&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$value&lt;/code&gt; 实际上是 &lt;code class=&quot;highlighter-rouge&quot;&gt;FooBar&lt;/code&gt; 对象。&lt;/p&gt;

&lt;p&gt;如果希望使用单例模式来实例化类，那么使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;App::singleton(&#39;foo&#39;, function()
{
    return new FooBar;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的话每次实例化后的都是同一个对象。&lt;/p&gt;

&lt;p&gt;注入类的更多例子可以看 &lt;a href=&quot;http://laravel.com/docs/4.2/ioc&quot;&gt;Laravel 官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;你可能会疑问上面的代码应该写在哪儿呢？答案是你希望他们在哪儿运行就写在哪儿。0 —— 0 知道写哪儿还用来看这种基础文章么！&lt;/p&gt;

&lt;h2 id=&quot;service-providers&quot;&gt;服务提供器 (Service Providers)&lt;/h2&gt;
&lt;p&gt;为了让依赖注入的代码不至于写乱，Laravel 搞了一个 &lt;strong&gt;服务提供器（Service Provider）&lt;/strong&gt;的东西，它将这些依赖聚集在了一块，统一申明和管理，让依赖变得更加容易维护。&lt;/p&gt;

&lt;h3 id=&quot;laravel--1&quot;&gt;Laravel 中的使用&lt;/h3&gt;
&lt;p&gt;定义一个服务提供器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Illuminate\Support\ServiceProvider;

class FooServiceProvider extends ServiceProvider {

    public function register()
    {
        $this-&amp;gt;app-&amp;gt;bind(&#39;foo&#39;, function()
        {
            return new Foo;
        });
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个代码也不难理解，就是申明一个服务提供器，这个服务提供器有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;register&lt;/code&gt; 的方法。这个方法实现了我们上面讲到的依赖注入。&lt;/p&gt;

&lt;p&gt;当我们执行下面代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;App::register(&#39;FooServiceProvider&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们就完成一个注入了。但是这个还是得手动写，所以怎么让 Laravel 自己来做这事儿呢？&lt;/p&gt;

&lt;p&gt;我们只要在 &lt;code class=&quot;highlighter-rouge&quot;&gt;app/config/app.php&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;providers&lt;/code&gt; 数组里面增加一行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&#39;providers&#39; =&amp;gt; [
    …
       ‘FooServiceProvider’,
],
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;App::make(‘foo’)&lt;/code&gt; 来实例化一个类了。&lt;/p&gt;

&lt;p&gt;你不禁要问了，这么写也太难看了吧？莫慌，有办法。&lt;/p&gt;

&lt;h2 id=&quot;facade&quot;&gt;门面模式（Facade）&lt;/h2&gt;
&lt;p&gt;为了让 Laravel 中的核心类使用起来更加方便，Laravel实现了门面模式。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;外觀模式（Facade pattern），是軟件工程中常用的一種軟件設計模式，它為子系統中的一組接口提供一個統一的高層接口，使得子系統更容易使用。 — &lt;a href=&quot;http://zh.wikipedia.org/wiki/外觀模式&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;laravel--2&quot;&gt;Laravel 中的使用&lt;/h3&gt;
&lt;p&gt;我们使用的大部分核心类都是基于门面模式实现的。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$value = Cache::get(&#39;key&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些静态调用实际上调用的并不是静态方法，而是通过 PHP 的魔术方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;__callStatic()&lt;/code&gt; 讲请求转到了相应的方法上。&lt;/p&gt;

&lt;p&gt;那么如何讲我们前面写的&lt;strong&gt;服务提供器&lt;/strong&gt;也这样使用呢？方法很简单，只要这么写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Illuminate\Support\Facades\Facade;

class Foo extends Facade {

    protected static function getFacadeAccessor() { return ‘foo’; }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo::test()&lt;/code&gt; 来调用我们之前真正的 &lt;code class=&quot;highlighter-rouge&quot;&gt;FooBar&lt;/code&gt; 类的方法了。&lt;/p&gt;

&lt;h2 id=&quot;alias&quot;&gt;别名（Alias）&lt;/h2&gt;
&lt;p&gt;有时候我们可能将 &lt;code class=&quot;highlighter-rouge&quot;&gt;Facade&lt;/code&gt; 放在我们扩展库中，它有比较深的命名空间，如：&lt;code class=&quot;highlighter-rouge&quot;&gt;\Library\MyClass\Foo&lt;/code&gt;。这样导致使用起来并不方便。Laravel 可以用别名来替换掉这么长的名字。&lt;/p&gt;

&lt;p&gt;我们只要在 &lt;code class=&quot;highlighter-rouge&quot;&gt;app/config/app.php&lt;/code&gt; 中 &lt;code class=&quot;highlighter-rouge&quot;&gt;aliases&lt;/code&gt; 下增加一行即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&#39;aliases&#39; =&amp;gt; [
    …
    &#39;Foo&#39; =&amp;gt; ‘Library\MyClass\Foo’,
],
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样它的使用就由 &lt;code class=&quot;highlighter-rouge&quot;&gt;\Library\MyClass\Foo::test()&lt;/code&gt; 变成 &lt;code class=&quot;highlighter-rouge&quot;&gt;Foo::test()&lt;/code&gt; 了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;所以有了&lt;strong&gt;控制反转（Inversion of Control）&lt;/strong&gt;和&lt;strong&gt;门面模式（Facade）&lt;/strong&gt;，实际还有 &lt;strong&gt;服务提供器（Service Providers）&lt;/strong&gt;和&lt;strong&gt;别名（Alias）&lt;/strong&gt;，我们创建自己的类库和扩展 Laravel 都会方便很多。&lt;/p&gt;

&lt;p&gt;这里总结一下创建自己类库的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;app/library/MyFoo&lt;/code&gt; 下创建类 &lt;code class=&quot;highlighter-rouge&quot;&gt;MyFoo.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;app/library/MyFoo/providers&lt;/code&gt; 下创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;MyFooServiceProvider.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;app/library/MyFoo/facades&lt;/code&gt; 下创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;MyFooFacade.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;app/config/app.php&lt;/code&gt; 中添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;providers&lt;/code&gt;  和 &lt;code class=&quot;highlighter-rouge&quot;&gt;aliases&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 06 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yansu.org/2014/12/06/ioc-and-facade-in-laravel.html</link>
        <guid isPermaLink="true">http://yansu.org/2014/12/06/ioc-and-facade-in-laravel.html</guid>
        
        <category>PHP</category>
        
        <category>Laravel</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
